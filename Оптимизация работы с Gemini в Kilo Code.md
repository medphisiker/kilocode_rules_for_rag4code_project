# **Оптимизация агентных рабочих процессов в Kilo Code: Архитектура, управление контекстом и интеграция Gemini 3**

## **Аннотация**

В современном ландшафте разработки программного обеспечения происходит фундаментальный сдвиг от простых инструментов автодополнения кода к автономным агентным системам, способным планировать, исполнять и поддерживать сложные архитектурные решения. Интеграция среды разработки **Kilo Code** с передовыми моделями Google — **Gemini 3 Pro** и **Gemini 3 Flash** — представляет собой вершину этой эволюции, предлагая разработчикам беспрецедентные возможности по управлению контекстом и логическому выводу. Данный отчет представляет собой исчерпывающее техническое руководство и аналитическое исследование, направленное на максимизацию эффективности работы в экосистеме Kilo Code.  
Основное внимание в отчете уделено трем критически важным компонентам, запрошенным пользователем: **Правилам проекта (Project Rules)**, **Навыкам агента (Agent Skills)** и **Банку памяти (Memory Bank)**. Анализ базируется на технических характеристиках моделей Gemini 3, особенностях файловой системы Kilo Code и передовых практиках сообщества разработчиков. В документе детально рассматриваются стратегии организации файловой структуры, синтаксис конфигураций и методы оркестрации, позволяющие трансформировать IDE из пассивного редактора в активного соавтора.

## ---

**Глава 1\. Вычислительное ядро: Специфика Gemini 3 в агентной среде**

Для эффективной организации правил, навыков и памяти необходимо глубокое понимание "двигателя", который приводит эти компоненты в действие. Kilo Code, будучи форком архитектурной линии Cline и Roo Code, предоставляет среду, но именно выбор моделей Gemini 3 определяет когнитивные способности агента.

### **1.1. Сравнительная архитектура моделей в контексте Kilo Code**

Пользователь использует тандем из **Gemini 3 Pro** и **Gemini 3 Flash**. Это стратегически верное решение, так как оно позволяет балансировать между глубиной рассуждений и скоростью исполнения. Понимание нюансов каждой модели критично для настройки режимов работы (Modes) в Kilo Code.

| Характеристика | Gemini 3 Pro | Gemini 3 Flash | Оптимальный режим Kilo Code | Сценарий использования |
| :---- | :---- | :---- | :---- | :---- |
| **Глубина рассуждений (Reasoning)** | Экстремально высокая. Модель способна удерживать сложные причинно-следственные связи и архитектурные абстракции. | Средняя/Высокая. Оптимизирована для скорости, но сохраняет способность к логическому выводу. | **Architect (Архитектор), Orchestrator (Оркестратор)** | Планирование системы, анализ Memory Bank, рефакторинг архитектуры. |
| **Окно контекста** | 1 миллион токенов (Preview). Позволяет загружать полную документацию и историю проекта. | 1 миллион токенов (Preview). Идентичный объем памяти при меньшей латентности. | **Ask (Вопрос), Debug (Отладка)** | Быстрый поиск по кодовой базе, исправление синтаксиса, генерация тестов. |
| **Латентность (Latency)** | Выше средней. Требует времени на "обдумывание" (Thinking process). | Сверхнизкая. Обеспечивает почти мгновенную обратную связь. | **Code (Кодер)** | Написание кода в реальном времени, работа в цикле REPL. |
| **Стоимость токена** | Премиальный сегмент. Требует экономного использования в масштабных итерациях. | Экономичный сегмент. Идеальна для массовых операций. | **Все режимы** | Повседневная разработка, рутинные задачи. |

**Аналитический инсайт:** Критическим преимуществом семейства Gemini 3 для реализации **Memory Bank** является окно контекста в 1 миллион токенов.1 В отличие от старых архитектур, где контекст приходилось агрессивно урезать или использовать векторный поиск (RAG) с потерей деталей, Gemini 3 позволяет загружать все файлы банка памяти (systemPatterns.md, active.md и др.) целиком. Это создает эффект "идеальной памяти", где модель видит не фрагменты, а целостную картину проекта.

### **1.2. Конфигурация параметров "Thinking" (Рассуждение)**

Особенностью Gemini 3 является нативная поддержка процесса "рассуждения" (thinking/reasoning), когда модель генерирует скрытую цепочку мыслей перед выдачей ответа. В Kilo Code это требует специфической настройки.

1. **Температурный режим (Temperature):** Для задач, требующих глубокого анализа (например, при работе с skills для документации или обновлении systemPatterns.md), рекомендуется устанавливать температуру для Gemini 3 Pro на уровне, близком к **0.6–0.7**, если модель поддерживает параметры "thinking", или строго **0.0** для детерминированного кода.3 Однако, некоторые реализации "думающих" моделей требуют фиксированной температуры **1.0**, чтобы не нарушать вероятностное распределение токенов в процессе внутреннего монолога.  
   * *Рекомендация:* Для режима **Architect** используйте Gemini 3 Pro с включенным отображением блоков рассуждений (thinking blocks). Это позволит вам верифицировать, правильно ли модель интерпретировала правила из Memory Bank, прежде чем она начнет генерировать план.1  
2. **Управление бюджетом токенов:** При использовании Memory Bank входной контекст (input context) будет постоянно большим. Gemini 3 Flash здесь выступает как идеальный "рабочий лошадка" (workhorse). Его низкая стоимость и высокая скорость позволяют перечитывать весь банк памяти при каждом новом запросе (turn) без существенных задержек, что делает работу с правилами и навыками бесшовной.1

## ---

**Глава 2\. Уровень управления: Организация Правил Проекта (Rules)**

Пользователь выразил желание эффективно использовать "правила проекта". В экосистеме Kilo Code правила (Rules) выступают в роли законодательной базы. Они определяют границы дозволенного, стиль кодирования и архитектурные ограничения, которые агент обязан соблюдать.

### **2.1. Иерархия и приоритетность правил**

Организация правил в Kilo Code не является плоской; она имеет строгую иерархию. Понимание механизма каскадной загрузки (cascading load) необходимо для предотвращения конфликтов между глобальными настройками и спецификой конкретного репозитория.

1. **Проектные правила (Project Rules) — .kilocode/rules/**  
   * *Приоритет:* **Высший**.  
   * *Назначение:* Эти правила переопределяют всё. Если в глобальных настройках указано "использовать Python", а в проектных "использовать Node.js", агент выберет Node.js. Это позволяет работать над разнородными проектами без постоянной перенастройки среды.  
   * *Локация:* Корневая папка проекта, директория .kilocode/rules/.  
2. **Глобальные правила (Global Rules) — \~/.kilocode/rules/**  
   * *Приоритет:* **Средний**.  
   * *Назначение:* Личные предпочтения разработчика, применимые ко всем проектам (например, "всегда отвечай на русском языке", "не используй console.log в финальном коде").  
   * *Локация:* Домашняя директория пользователя.  
3. **Режимные правила (Mode-Specific Rules) — .kilocode/rules-\<mode\>/**  
   * *Приоритет:* **Контекстный**.  
   * *Назначение:* Инструкции, актуальные только для конкретного режима (Architect, Code, Debug). Например, правило "Не пиши код, только планируй" должно действовать только для режима Architect.6

**Инсайт:** Переход от устаревших монолитных файлов (таких как .clinerules или .roorules) к модульной структуре директорий .kilocode/rules/ является критическим улучшением. Это позволяет моделям Gemini 3 лучше структурировать информацию, так как каждый файл правил воспринимается как отдельный семантический блок.6

### **2.2. Стратегия организации файлов правил**

Для максимальной эффективности рекомендуется отказаться от использования одного большого текстового файла. Вместо этого следует применять модульный подход с использованием Markdown. Структурированный текст (заголовки, списки, блоки кода) обрабатывается LLM значительно эффективнее, чем сплошное повествование.6

#### **Рекомендуемая структура файловой системы**

project-root/  
└──.kilocode/  
├── rules/ \<-- Общие правила проекта  
│ ├── 01-style-guide.md \# Стандарты кодирования (Naming, Formatting)  
│ ├── 02-security.md \# Безопасность (Secret management, Access)  
│ ├── 03-testing.md \# Стратегии тестирования (Unit, Integration)  
│ └── 99-workflow.md \# Форматы коммитов, работа с Git  
├── rules-architect/ \<-- Правила для режима Архитектора  
│ └── planning-protocol.md \# Инструкция: "Сначала читай Memory Bank"  
└── rules-code/ \<-- Правила для режима Кодера  
└── implementation.md \# Инструкция: "Пиши тесты до реализации"

### **2.3. Детальное содержание правил (Примеры)**

#### **2.3.1. Файл 01-style-guide.md**

Этот файл разгружает контекстное окно оперативной памяти, избавляя вас от необходимости повторять требования к стилю в каждом промпте.  
**Пример содержания:**

# **Стандарты кодирования проекта**

## **Основные принципы**

* **Язык:** TypeScript в строгом режиме (Strict mode).  
* **Функциональный стиль:** Предпочтение чистым функциям и иммутабельности данных.  
* **Типизация:** Запрещено использование any. Все типы должны быть явно определены или выводимы.

## **Соглашения об именовании**

* Переменные и функции: camelCase  
* Компоненты React: PascalCase  
* Константы: UPPER\_SNAKE\_CASE  
* Интерфейсы: Префикс I не используется (например, UserProps, а не IUserProps).

## **Форматирование**

* Использовать конфигурацию Prettier проекта.  
* Максимальная длина строки: 100 символов.

#### **2.3.2. Файл 02-security.md**

Учитывая, что Kilo Code имеет доступ к файловой системе и терминалу, правила безопасности действуют как "защитные ограждения" (guardrails).  
**Пример содержания:**

# **Политика безопасности**

## **Работа с секретами**

* **ЗАПРЕЩЕНО:** Выводить в чат, логи или файлы кода любые API ключи, пароли или токены.  
* **ТРЕБОВАНИЕ:** Все секреты должны читаться исключительно из переменных окружения (process.env).  
* **Файлы:** Никогда не читать и не редактировать файлы .env напрямую без явной команды пользователя.

## **Установка зависимостей**

* Перед установкой новых пакетов через npm или pip необходимо запросить разрешение пользователя.  
* Использовать только стабильные версии библиотек.

**Технический нюанс:** Kilo Code автоматически считывает содержимое этих файлов при каждой инициализации сессии или смене режима. Благодаря огромному контекстному окну Gemini 3 Pro, даже объемные правила не "вымываются" из памяти модели, обеспечивая стабильное соблюдение конвенций на протяжении всей сессии.9

## ---

**Глава 3\. Уровень возможностей: Реализация Навыков Агента (Skills)**

Пользователь особо отметил желание использовать **Skills** для описания работы с определенными задачами, например, для создания документации. В терминологии Kilo Code "Навыки" (Skills) — это специализированные, повторно используемые инструкции или мини-программы, которые агент может "подключать" по требованию. В отличие от пассивных правил, навыки — это активные инструменты.11

### **3.1. Анатомия навыка (Skill)**

Навык представляет собой директорию с обязательным файлом SKILL.md. Критически важно соблюдать соглашение об именовании: имя папки должно точно совпадать с полем name в метаданных (YAML frontmatter) файла.7  
**Локация навыков:**

* **Глобальные:** \~/.kilocode/skills/ (доступны везде).  
* **Проектные:** .kilocode/skills/ (специфичны для репозитория).

**Структура:**  
.kilocode/  
└── skills/  
└── documentation-writer/ \<-- Имя папки  
└── SKILL.md \<-- Файл определения

### **3.2. Кейс: Создание навыка "Documentation Writer"**

Пользователь запросил пример навыка для документации. Это идеальный сценарий, так как документация требует специфического тона (Voice & Tone) и форматирования, отличного от написания кода.

#### **3.2.1. Содержание файла SKILL.md**

Ниже приведен готовый к использованию шаблон для навыка создания документации, оптимизированный для Gemini 3\.

## ---

**name: documentation-writer description: Специализированный навык для написания, обновления и форматирования технической документации, включая README, API references и JSDoc. version: 1.0.0**

# **Навык: Технический Писатель (Documentation Writer)**

## **Назначение**

Этот навык активируется, когда пользователю требуется создать или обновить документацию. Агент должен переключиться в режим "Технического писателя", уделяя внимание ясности, структуре и точности, а не генерации исполняемого кода.

## **Триггеры (Когда использовать)**

Используйте этот навык, когда пользователь просит:

* "Обнови README"  
* "Напиши документацию к этой функции"  
* "Создай руководство пользователя"  
* "Задокументируй API"

## **Инструкции по исполнению**

### **1\. Тон и Стиль (Tone of Voice)**

* **Профессиональный:** Используйте точный технический язык. Избегайте сленга.  
* **Активный залог:** "Система обрабатывает данные", а не "Данные обрабатываются системой".  
* **Лаконичность:** Используйте маркированные списки вместо длинных абзацев.

### **2\. Стандарты форматирования**

* **Markdown:** Вся документация должна быть в формате Markdown (.md).  
* **Заголовки:** Используйте иерархию заголовков (\#, \#\#, \#\#\#).  
* **Блоки кода:** Всегда указывайте язык в блоках кода (например,typescript).

### **3\. Шаблон документации API**

При документировании эндпоинта или функции следуйте шаблону:

#### **\[Имя функции/метода\]**

**Описание:** Краткое резюме (1-2 предложения).  
**Параметры:**

* paramName (Тип): Описание параметра.  
  **Возвращает:**  
* (Тип): Описание возвращаемого значения.  
  **Пример:**

JavaScript

// Пример использования  
const result \= calculateTotal(items);

### **4\. Верификация**

* Проверьте, что все внутренние ссылки в документации работают.  
* Убедитесь, что примеры кода синтаксически корректны и соответствуют текущей версии кода.

\#\#\#\# 3.2.2. Механика работы навыка  
Когда вы пишете в чат: \*"Kilo, обнови документацию для контроллера авторизации"\*, механизм оркестрации Kilo Code анализирует доступные навыки. Он сопоставляет ваш запрос с полем \`description\` навыка \`documentation-writer\`. Обнаружив совпадение, он загружает содержимое \`SKILL.md\` в контекст Gemini 3\.

Модель Gemini 3, обладая высокой способностью к следованию инструкциям (instruction following), перестраивает свой стиль генерации текста согласно разделу "Тон и Стиль" и использует предписанный "Шаблон документации API". Без этого навыка модель могла бы сгенерировать документацию в произвольном стиле, который мог бы не соответствовать стандартам вашей компании.

\#\#\# 3.3. Навыки против Кастомных Режимов (Custom Modes)

Важно различать навыки и кастомные режимы, так как пользователь спрашивал об общей организации.

\*   \*\*Кастомный режим (Custom Mode):\*\* Это полноценная "персона" агента (например, "Режим Технического Писателя"), выбираемая в выпадающем меню. Он может иметь свои ограничения доступа (например, только чтение файлов). Режимы лучше использовать для длительных сессий, посвященных одному типу деятельности.  
\*   \*\*Навык (Skill):\*\* Это "инструмент", который можно достать из ящика в любой момент. Навыки более гибки. Вы можете находиться в режиме "Кодер" (Code Mode), писать функцию, и тут же попросить "задокументировать её", используя навык, не переключая режим.

\*\*Рекомендация:\*\* Начните с создания \*\*Skills\*\*. Это более гибкий подход, позволяющий Gemini 3 Flash динамически подгружать инструкции без разрыва контекста сессии.

\---

\#\# Глава 4\. Персистентная память: Организация Memory Bank

\*\*Memory Bank\*\* (Банк Памяти) — это ключевой элемент для работы с Gemini 3\. Он решает проблему "амнезии ИИ", создавая структурированное хранилище знаний о проекте, которое переживает перезагрузку редактора. Для моделей с окном в 1 миллион токенов Memory Bank становится не просто справочником, а "долгосрочной памятью".\[9, 10, 12\]

\#\#\# 4.1. Файловая структура Memory Bank

Memory Bank — это не база данных, а набор Markdown-файлов в папке \`.kilocode/rules/memory-bank/\`. Kilo Code запрограммирован искать файлы с определенными именами.

\*\*Обязательная директория:\*\* \`.kilocode/rules/memory-bank/\`

Ниже представлена таблица с описанием основных файлов, их назначением и частотой обновления.

| Файл | Назначение (Роль в системе) | Содержание | Частота обновления |  
| :--- | :--- | :--- | :--- |  
| \*\*\`active.md\`\*\* | \*\*Рабочая память (Context).\*\* Текущий фокус внимания агента. | Текущая задача, список незавершенных шагов, контекст последней сессии. | Постоянно (в конце каждой сессии или этапа). |  
| \*\*\`product.md\`\*\* | \*\*Видение (Vision).\*\* Описание продукта и целей. | "Что мы строим?", "Для кого?", "Ключевые метрики успеха". | Редко (при смене бизнес-целей). |  
| \*\*\`systemPatterns.md\`\*\* | \*\*Архитектура (Architecture).\*\* Технические стандарты и паттерны. | "Используем MVC", "Стейт-менеджмент через Redux", "Обработка ошибок через middleware". | При изменении архитектурных решений. |  
| \*\*\`techContext.md\`\*\* | \*\*Стек (Stack).\*\* Технические ограничения и окружение. | Версии языков (Node 20, Python 3.11), базы данных, внешние API. | При обновлении зависимостей. |  
| \*\*\`progress.md\`\*\* | \*\*Статус (Status).\*\* Глобальный трекинг прогресса. | Реализованные фичи, бэклог, известные проблемы. | После завершения крупных эпиков/задач. |  
| \*\*\`brief.md\`\*\* | \*\*Основа (Foundation).\*\* Краткое описание сути проекта. | Лаконичное описание для быстрой инициализации новых сессий. | Крайне редко. |

\#\#\# 4.2. Рабочий процесс: Инициализация и Поддержка

Пользователь спрашивал: \*"Как мне это все лучше организовать?"\*. Ответ кроется в строгой дисциплине ведения Memory Bank.

\#\#\#\# Этап 1: Инициализация (Bootstrap)  
Если вы начинаете работу с существующим проектом в Kilo Code:  
1\.  Создайте папку \`.kilocode/rules/memory-bank/\`.  
2\.  Создайте файл \`brief.md\` и напишите туда 2-3 предложения о сути проекта.  
3\.  \*\*Действие:\*\* Переключитесь в режим \*\*Architect (Архитектор)\*\*. Используйте модель Gemini 3 Pro (из-за ее аналитических способностей).  
4\.  \*\*Промпт:\*\* \*"Инициализируй Memory Bank. Просканируй кодовую базу (package.json, структуру src, конфиги) и создай файлы \`product.md\`, \`systemPatterns.md\` и \`techContext.md\`, отражающие текущее состояние проекта."\*

Gemini 3 Pro проанализирует структуру файлов и автоматически заполнит файлы банка памяти. Это создаст "снимок" состояния проекта.\[10\]

\#\#\#\# Этап 2: Активный цикл (The Active Loop)  
При каждом начале работы Kilo Code считывает эти файлы.  
\*   \*\*Сценарий:\*\* Вы просите \*"Добавь новую ручку API для логина"\*.  
\*   \*\*Действие агента:\*\* Агент читает \`systemPatterns.md\`, видит, что вы используете определенный паттерн для контроллеров (например, NestJS decorators), и читает \`techContext.md\`, чтобы узнать версию библиотеки.  
\*   \*\*Результат:\*\* Код генерируется сразу в правильном стиле, без дополнительных уточнений.

\#\#\#\# Этап 3: Протокол обновления (Update Protocol)  
Самая важная часть организации. Агент не всегда обновляет память сам.  
\*   \*\*Правило:\*\* После завершения задачи дайте команду: \*"Обнови Memory Bank. Запиши в \`progress.md\`, что задача выполнена, и очисти \`active.md\` для следующей сессии."\*  
\*   \*\*Автоматизация:\*\* Можно добавить правило в \`.kilocode/rules/99-workflow.md\`: \*"В конце каждой задачи предлагай пользователю обновить Memory Bank."\*

\#\#\# 4.3. Оптимизация под Gemini 3 (1M Tokens)

В отличие от моделей с маленьким контекстом (Claude 3.5 Sonnet или GPT-4), Gemini 3 позволяет вам быть многословными в Memory Bank.  
\*   \*\*Совет:\*\* В файл \`systemPatterns.md\` можно добавить реальные примеры кода "Как надо" и "Как не надо" (Anti-patterns). Gemini 3 Pro способна "выучить" эти примеры и применять их по аналогии.  
\*   \*\*Предостережение:\*\* Хотя контекст велик, чтение 50k токенов документации в каждом запросе увеличивает латентность (время до начала ответа). Gemini 3 Flash нивелирует эту проблему своей скоростью, но Gemini 3 Pro может "думать" дольше.  
\*   \*\*Решение:\*\* Используйте \`skills\` для ситуативных задач, а \`Memory Bank\` — для фундаментальных знаний, которые нужны всегда.\[1\]

\---

\#\# Глава 5\. Интеграция и Ежедневный Рабочий Процесс (Kilo Flow)

Синтезируя все вышесказанное, предлагается следующая схема ежедневной работы ("Kilo Flow"), отвечающая на вопрос \*"Как это лучше организовать?"\*.

\#\#\# 5.1. Организация файловой системы

Унифицированная структура вашего проекта должна выглядеть так:

/my-awesome-project  
├──.kilocode/  
│   ├── rules/                       \<-- ЗАКОНЫ  
│   │   ├── memory-bank/             \<-- МОЗГ  
│   │   │   ├── active.md  
│   │   │   ├── systemPatterns.md  
│   │   │   └──...  
│   │   ├── 00-general.md  
│   │   └── 90-secrets.md  
│   ├── skills/                      \<-- ИНСТРУМЕНТЫ  
│   │   ├── documentation/  
│   │   │   └── SKILL.md  
│   │   └── unit-testing/  
│   │       └── SKILL.md  
└── src/...

\#\#\# 5.2. Сценарий: Реализация новой фичи

1\.  \*\*Планирование (Режим Architect \+ Gemini 3 Pro)\*\*  
    \*   Агент загружает \`memory-bank/\*\`.  
    \*   Вы описываете задачу.  
    \*   Gemini 3 Pro анализирует \`systemPatterns.md\` и предлагает план.  
    \*   Агент записывает план в \`memory-bank/active.md\`.

2\.  \*\*Исполнение (Режим Code \+ Gemini 3 Flash)\*\*  
    \*   Вы переключаетесь в режим Code (для скорости).  
    \*   Агент читает \`active.md\` (план) и \`rules/01-style-guide.md\` (правила).  
    \*   Агент пишет код, следуя плану шаг за шагом.  
    \*   Используется навык \`unit-testing\` (если настроен) для генерации тестов.

3\.  \*\*Завершение (Режим Ask/Orchestrator)\*\*  
    \*   Вы просите: "Задокументируй изменения и обнови статус".  
    \*   Агент активирует навык \`documentation-writer\`, создает.md файлы.  
    \*   Агент обновляет \`memory-bank/progress.md\` и очищает \`active.md\`.

\---

\#\# Глава 6\. Продвинутые возможности и MCP

Хотя пользователь не спрашивал напрямую про MCP (Model Context Protocol), упоминание "skills" и "memory bank" в исследовании часто пересекается с MCP. Kilo Code поддерживает подключение внешних MCP-серверов.

\*   \*\*Что это дает?\*\* Вы можете подключить MCP-сервер базы данных (Postgres) или GitHub. Это позволит агенту не просто читать файлы \`memory-bank\`, но и делать SQL-запросы к реальной базе данных для понимания структуры данных, или читать Issues из GitHub.  
\*   \*\*Интеграция:\*\* Настройка MCP производится через конфигурационный файл (обычно \`claude\_desktop\_config.json\` или аналог в настройках Kilo), где прописываются пути к серверам. Это следующий уровень организации после внедрения Skills и Memory Bank.\[13, 14\]

\---

\#\# Заключение

Эффективная организация работы в Kilo Code с использованием Gemini 3 строится на трех столпах:  
1\.  \*\*Правила (Rules):\*\* Жесткие ограничения, загружаемые автоматически. Используйте их для стайлгайдов и безопасности.  
2\.  \*\*Навыки (Skills):\*\* Подключаемые модули для специфических задач (документация, тесты). Они дают гибкость.  
3\.  \*\*Memory Bank:\*\* Долгосрочная память проекта. Использование окна контекста Gemini 3 в 1 миллион токенов позволяет держать всю архитектуру проекта "в голове" у агента.

Внедрение предложенной файловой структуры \`.kilocode/\` и соблюдение дисциплины обновления файлов банка памяти трансформирует Kilo Code из простого помощника в полноценного автономного партнера по разработке. Gemini 3 Pro обеспечивает качество планирования, а Gemini 3 Flash — скорость исполнения, создавая бесшовный и высокопродуктивный рабочий процесс.

#### **Источники**

1. AI Coding Models | Compare 500+ LLMs for Development \- Kilo Code, дата последнего обращения: января 31, 2026, [https://kilo.ai/models](https://kilo.ai/models)  
2. Gemini 3 Pro Preview \- API, Providers, Stats \- OpenRouter, дата последнего обращения: января 31, 2026, [https://openrouter.ai/google/gemini-3-pro-preview](https://openrouter.ai/google/gemini-3-pro-preview)  
3. Model Temperature | Kilo Code Docs, дата последнего обращения: января 31, 2026, [https://kilo.ai/docs/features/model-temperature](https://kilo.ai/docs/features/model-temperature)  
4. README.md · zai-org/GLM-4.7 at refs/pr/31 \- Hugging Face, дата последнего обращения: января 31, 2026, [https://huggingface.co/zai-org/GLM-4.7/blob/refs%2Fpr%2F31/README.md](https://huggingface.co/zai-org/GLM-4.7/blob/refs%2Fpr%2F31/README.md)  
5. Gemini 3 Flash Preview \- API, Providers, Stats \- OpenRouter, дата последнего обращения: января 31, 2026, [https://openrouter.ai/google/gemini-3-flash-preview](https://openrouter.ai/google/gemini-3-flash-preview)  
6. Custom Rules | Kilo Code Docs, дата последнего обращения: января 31, 2026, [https://kilo.ai/docs/agent-behavior/custom-rules](https://kilo.ai/docs/agent-behavior/custom-rules)  
7. Skills \- Kilo Code, дата последнего обращения: января 31, 2026, [https://kilo.ai/docs/customize/skills](https://kilo.ai/docs/customize/skills)  
8. Custom Rules \- Kilo Code, дата последнего обращения: января 31, 2026, [https://kilo.ai/docs/customize/custom-rules](https://kilo.ai/docs/customize/custom-rules)  
9. Kilo Code (Kilo AI) Review 2025: Agentic Coding, Privacy & Open ..., дата последнего обращения: января 31, 2026, [https://skywork.ai/blog/kilo-code-ai-review-2025-open-source-agentic-vs-copilot/](https://skywork.ai/blog/kilo-code-ai-review-2025-open-source-agentic-vs-copilot/)  
10. Memory Bank \- Kilo Code, дата последнего обращения: января 31, 2026, [https://kilo.ai/docs/customize/context/memory-bank?ref=mbohlen.de](https://kilo.ai/docs/customize/context/memory-bank?ref=mbohlen.de)  
11. Skills | Kilo Code Docs, дата последнего обращения: января 31, 2026, [https://kilo.ai/docs/agent-behavior/skills](https://kilo.ai/docs/agent-behavior/skills)